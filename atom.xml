<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bryon</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.bryon.cn/"/>
  <updated>2017-03-18T16:11:24.956Z</updated>
  <id>www.bryon.cn/</id>
  
  <author>
    <name>bryon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="www.bryon.cn//blog/2017/03/18/ProtocolBuffers%E5%88%9D%E6%8E%A2.html"/>
    <id>www.bryon.cn//blog/2017/03/18/ProtocolBuffers初探.html</id>
    <published>2017-03-17T16:00:00.000Z</published>
    <updated>2017-03-18T16:11:24.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Protocol-Buffers是什么"><a href="#Protocol-Buffers是什么" class="headerlink" title="Protocol Buffers是什么?"></a>Protocol Buffers是什么?</h2><p>它是google开源的一个项目，Google给出的定义是<a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="external">Protocol buffers are a flexible,efficent,automated mechanism for serializing structured data-think XML,but smaller,faster,and simpler</a>.它其实就是一个数据描述语言，它能够将<strong>结构化</strong>的数据序列化，以用于<strong>数据存储</strong>，<strong>通信协议</strong>等方面。相较于JSON,XML等文本格式，Protobuf 主要是binary bits的。并且它还是跨平台,跨语言的.支持<strong>c++</strong>，<strong>java</strong>,<strong>c</strong>#,<strong>python</strong>…..</p>
<h2 id="Protocol-Buffers是怎么工作的？"><a href="#Protocol-Buffers是怎么工作的？" class="headerlink" title="Protocol Buffers是怎么工作的？"></a>Protocol Buffers是怎么工作的？</h2><p>它主要通过在<code>.proto</code>文件中定义protobuf的消息类型进行序列化/反序列化。消息主要是由name-value pairs构成的。比如举一个简单的<code>.proto</code>文件消息格式.</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">Student</span> </span>&#123;</div><div class="line">  <span class="keyword">required</span> <span class="built_in">string</span> name = <span class="number">1</span>;</div><div class="line">  <span class="keyword">required</span> <span class="built_in">int32</span> id = <span class="number">2</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> email = <span class="number">3</span>;</div><div class="line"> </div><div class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">PhoneType</span> </span>&#123;</div><div class="line">    MOBLILE = <span class="number">0</span>;</div><div class="line">    HOME = <span class="number">1</span>;</div><div class="line">    WORK = <span class="number">2</span>;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="class"><span class="keyword">message</span> <span class="title">PhoneNumber</span> </span>&#123;</div><div class="line">   <span class="keyword">required</span> <span class="built_in">string</span> number = <span class="number">1</span>;</div><div class="line">   <span class="keyword">optional</span> PhoneType type = <span class="number">2</span> [default = HOME];</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">repeated</span> PhoneNumber phone = <span class="number">4</span>;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>1 这里面每个消息中的字段都是由数字进行编号的如1，2，3…,而且消息类型可以嵌套，其中value有多种类型如int32，int64,uint32,uint64,sint32,sint64,bool,enum,fixed64,sfixed64,double,string,bytes,embedded messages,packed repeated fields,fixed32,sfixed32,float.等等共分为四大类依次以<strong>Varint</strong> 0,<strong>64-bit</strong> 1,<strong>Length-delim</strong>i 2,<strong>32-bit</strong> 5.这其中主要采用了它自身的编码进行命名的，与我们平常的分类不太一样,等到后面源码分析的时候具体讨论.</p>
</li>
<li><p>2 另外每个field前面可能会出现<strong>required/optional/repeated</strong>等修饰词表示对应字段的属性.</p>
</li>
<li><p>3 有了上面的<code>.proto</code>文件，你就可以通过对应语言的protocol buffer compiler编译产生对应消息格式的类.通过这些类，你可以获取消息格式中对应的字段并且可以通过类中的方法来将相应的结构化数据转成原始字节或则把原始字节转化成结构化的消息.<br>例如对于c++就可以在自己的代码中操作这些消息类如Student:</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Student student;</div><div class="line">student.set<span class="number">_n</span>ame(<span class="string">"bryon"</span>);</div><div class="line">student.set<span class="number">_</span>id(<span class="number">12345</span>);</div><div class="line">student.set<span class="number">_</span>email(<span class="string">"chaojinyao@gmail.com"</span>); <span class="comment">//这个为可选项</span></div><div class="line">fstream <span class="keyword">out</span>(<span class="string">"myfile"</span>,ios::<span class="keyword">out</span>| ios::binary);</div><div class="line">student.SerializeToOStream(&amp;<span class="keyword">out</span>);    <span class="comment">// 序列化</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>当然你也能从代码中把这个序列化后的内容转成对应的结构化数据.<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fstream <span class="keyword">in</span>(<span class="string">"myfile"</span>,<span class="string">ios:</span>:<span class="keyword">in</span> | <span class="string">ios:</span>:binary);</div><div class="line">Student student;</div><div class="line">student.ParseFromIstream(&amp;<span class="keyword">in</span>); <span class="comment">//反序列化</span></div><div class="line"><span class="comment">//接下来就可以运用student中的数据了.</span></div><div class="line">cout&lt;&lt;student.name()&lt;&lt;endl;</div></pre></td></tr></table></figure></p>
<p>当然还有一个很大的好处是你在消息中添加/删除字段并不影响以前的二进制流，它解析的时候会忽略这个字段，具有很好的向后兼容性。</p>
<h2 id="它与传统的xml格式消息相比怎么样呢？"><a href="#它与传统的xml格式消息相比怎么样呢？" class="headerlink" title="它与传统的xml格式消息相比怎么样呢？"></a>它与传统的xml格式消息相比怎么样呢？</h2><p>protobuf在序列化结构化数据时有很多<strong>优点</strong>:</p>
<ol>
<li>简单</li>
<li>表示相同message所需字节更少</li>
<li>解析的速度更快</li>
<li>能产生更利于编码的消息字段获取函数/设置函数</li>
</ol>
<p>比如一个student需要name,id字段那么他们表示的消息格式如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>bryon<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>1234567<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>而protocol buffer 中是这样的:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">student</span> &#123;</div><div class="line">  <span class="attribute">name</span>: <span class="string">"bryon"</span></div><div class="line">  id: <span class="number">1234567</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样一比较明显可以看出protobuf描述同样一个结构化数据所需的空间更小。而且protobuf还有自己的一套编码方案，将他们序列化程二进制时占用空间更小。</p>
<p>但是protobuf也有它的<strong>缺点</strong>：它就不能对例如html等文档进行有效的表示，并且它也没有xml更有可读性，它还需要<code>.proto</code>文件才能正常工作.</p>
<p>参考：<br>1: <a href="https://github.com/cjYao/protobuf/blob/master/src/README.md" target="_blank" rel="external">https://github.com/cjYao/protobuf/blob/master/src/README.md</a><br>2: <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/</a><br>3: <a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="external">https://developers.google.com/protocol-buffers/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Protocol-Buffers是什么&quot;&gt;&lt;a href=&quot;#Protocol-Buffers是什么&quot; class=&quot;headerlink&quot; title=&quot;Protocol Buffers是什么?&quot;&gt;&lt;/a&gt;Protocol Buffers是什么?&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
      <category term="ProtocolBuffers" scheme="www.bryon.cn/categories/ProtocolBuffers/"/>
    
    
  </entry>
  
  <entry>
    <title>关于replication与cache的一点思考</title>
    <link href="www.bryon.cn//blog/2016/09/02/2016-09-02.html"/>
    <id>www.bryon.cn//blog/2016/09/02/2016-09-02.html</id>
    <published>2016-09-02T03:57:04.000Z</published>
    <updated>2016-09-02T05:57:27.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cache-与-replication"><a href="#cache-与-replication" class="headerlink" title="cache 与 replication"></a>cache 与 replication</h2><ul>
<li><strong>为什么会出现cache与replication</strong>: 随着系统的规模与复杂性逐渐提升,系统的延迟会进一步提升，那么为了解决client/appication获取资源的延迟，就出现了缓存，副本。它们主要是对资源所在服务器的一些数据预先保存到cache/replication服务器中或则存到缓存中,一方面降低资源请求的延迟，提高存取效率，另一方面，对单点服务器的访问压力会极大缩小从而降低服务器发生故障的危险。</li>
<li><p><strong>cache与replication之间的比较</strong>：</p>
<ol>
<li><p>replication可以用来解决单点服务器访问性能问题，cache也可以，但是对于replication第一次访问时数据已经在对应的副本里，而cache第一次访问时，数据几乎都不命中，当然你可以采用预取机制来进行提前把数据放到cache中，这可能会有所改善。</p>
</li>
<li><p>replication可以作为数据备份系统，而cache一般不可以。但是这也是replication的一个缺点，虽然它实现了fault tolerant,但是数据之间的更新，传输都将使得系统变得复杂，即带来了多个服务器间的一致性问题.硬盘所需的空间也比较大。当然对于replication系统我们也可以把它做成主设备进行更新操作，这些replica设备只进行读操作。从而降低不一致问题。这与cache作为内存缓存时是差不多的.</p>
</li>
<li><p>cache一个大的用途还可以用在内存缓存中，解决程序从磁盘读取数据慢的问题。</p>
</li>
<li><p>结合replication与cache的优缺点得出：加入预取机制的cache系统搭建起来更便宜而且比较简单，而replication相对就比较复杂。不过高可用系统感觉加上replication作为备份系统比较合适。当然两者可以进行结合。在cache中加入副本.</p>
</li>
</ol>
</li>
<li><p><strong>结论</strong>：<br>  其实副本与缓存本身概念之间就存在共同点，从某一方面来说它们都可以加速数据的获取，当然副本更多的是用在备份系统，提高数据的容错性，可以进行错误恢复。而cache这个概念更多的是进行部分小数据量的缓存，方面快速读取，简单高效。</p>
<p>  最近一直在进行NYU mit distributed system 课程的学习 ，后面会陆续加上对源码的解读与分析.</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;cache-与-replication&quot;&gt;&lt;a href=&quot;#cache-与-replication&quot; class=&quot;headerlink&quot; title=&quot;cache 与 replication&quot;&gt;&lt;/a&gt;cache 与 replication&lt;/h2&gt;&lt;ul&gt;

    
    </summary>
    
      <category term="distributed system" scheme="www.bryon.cn/categories/distributed-system/"/>
    
    
      <category term="缓存cache" scheme="www.bryon.cn/tags/%E7%BC%93%E5%AD%98cache/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="www.bryon.cn//blog/2016/08/14/hello-world.html"/>
    <id>www.bryon.cn//blog/2016/08/14/hello-world.html</id>
    <published>2016-08-14T09:46:15.339Z</published>
    <updated>2016-08-14T09:46:15.339Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
